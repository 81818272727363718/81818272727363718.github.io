<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini Plants vs Zombies Clone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #2b5c2b 0, #062006 45%, #020603 100%);
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    #game-container {
      background: rgba(0,0,0,0.35);
      border-radius: 18px;
      padding: 16px 16px 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(10px);
    }

    h1 {
      text-align: center;
      margin-bottom: 8px;
      letter-spacing: 1px;
      font-size: 24px;
      text-shadow: 0 0 6px #0f0;
    }

    #top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 8px;
    }

    #sun-counter {
      padding: 6px 10px;
      background: rgba(255,255,255,0.08);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      font-size: 14px;
    }

    #status-text {
      font-size: 13px;
      opacity: 0.85;
    }

    button {
      cursor: pointer;
      border-radius: 999px;
      border: 0;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 600;
      background: linear-gradient(135deg, #39e27a, #8bf58d);
      color: #03240b;
      box-shadow: 0 0 12px rgba(0,0,0,0.4);
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease, filter 0.15s;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 16px rgba(0,0,0,0.6);
      filter: brightness(1.05);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
      filter: brightness(0.95);
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    /* Seed bank */
    #seed-bank {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .seed-card {
      width: 100px;
      height: 60px;
      border-radius: 10px;
      background: linear-gradient(145deg, #f7f7c1, #f0e5a2);
      border: 2px solid #c1b676;
      box-shadow: 0 3px 0 #8c8151;
      position: relative;
      padding: 4px 6px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      color: #332b1a;
      user-select: none;
      transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s;
    }

    .seed-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 0 #8c8151;
      filter: brightness(1.05);
    }

    .seed-card.selected {
      box-shadow: 0 0 0 2px #00ff99, 0 3px 0 #8c8151;
    }

    .seed-name {
      font-weight: 700;
    }

    .seed-cost {
      font-size: 11px;
      opacity: 0.85;
    }

    /* Board */
    #board {
      position: relative;
      width: 720px; /* 9 cols * 80px */
      height: 400px; /* 5 rows * 80px */
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(255,255,255,0.2);
      background: linear-gradient(180deg, #4b7a2d, #32511f);
      box-shadow: inset 0 0 12px rgba(0,0,0,0.6);
    }

    #grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(5, 1fr);
      width: 100%;
      height: 100%;
      position: relative;
      z-index: 1;
    }

    .cell {
      border: 1px solid rgba(0,0,0,0.2);
      background: rgba(255,255,255,0.04);
      position: relative;
      cursor: pointer;
    }

    .cell:nth-child(odd) {
      background: rgba(255,255,255,0.03);
    }

    .cell:hover {
      outline: 2px solid rgba(255,255,255,0.3);
      outline-offset: -2px;
    }

    .plant {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 20%, #7ef57e, #2d8a2d);
      border: 2px solid #1a541a;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #032403;
      font-size: 22px;
      font-weight: 900;
      text-shadow: 0 0 4px rgba(255,255,255,0.6);
    }

    #entities {
      position: absolute;
      inset: 0;
      z-index: 2;
      pointer-events: none; /* do not block clicks on cells */
    }

    .zombie {
      position: absolute;
      width: 60px;
      height: 80px;
      border-radius: 10px;
      background: linear-gradient(180deg, #719c61, #3e5a37);
      border: 2px solid #20331f;
      box-shadow: 0 0 10px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e1ffe1;
      font-size: 14px;
    }

    .zombie::before {
      content: "ðŸ§Ÿ";
      font-size: 24px;
      margin-bottom: 2px;
    }

    .bullet {
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: radial-gradient(circle, #c7ff4f, #4baa10);
      box-shadow: 0 0 8px rgba(190,255,90,0.9);
    }

    #overlay-message {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.55);
      z-index: 5;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    #overlay-message.visible {
      opacity: 1;
      pointer-events: all;
    }

    #overlay-box {
      padding: 16px 20px;
      border-radius: 14px;
      background: rgba(0,0,0,0.85);
      border: 1px solid rgba(255,255,255,0.2);
      text-align: center;
      max-width: 260px;
    }

    #overlay-box h2 {
      margin-bottom: 10px;
      font-size: 18px;
    }

    #overlay-box p {
      font-size: 13px;
      margin-bottom: 12px;
      opacity: 0.9;
    }

    /* Mobile tweaks */
    @media (max-width: 760px) {
      #board {
        width: 100%;
        height: calc(100vw * (400 / 720)); /* keep aspect ratio */
      }
      #game-container {
        width: 100%;
        max-width: 760px;
        margin: 8px;
      }
      .seed-card {
        width: 90px;
        height: 56px;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <h1>Plants vs Zombies â€“ Mini Clone</h1>

    <div id="top-bar">
      <div id="sun-counter">â˜€ Sun: <span id="sun-amount">150</span></div>
      <div id="status-text">Click a seed, then click a tile to place a plant.</div>
      <button id="start-button">Start Wave</button>
    </div>

    <div id="seed-bank">
      <div class="seed-card selected" data-plant="peashooter" data-cost="100">
        <div class="seed-name">Peashooter</div>
        <div class="seed-cost">Cost: 100 â˜€</div>
        <div style="font-size:11px; opacity:0.8;">Shoots peas at zombies.</div>
      </div>
      <!-- Add more plant cards later if you want -->
    </div>

    <div id="board">
      <div id="grid"></div>
      <div id="entities"></div>

      <div id="overlay-message">
        <div id="overlay-box">
          <h2 id="overlay-title">Game Over</h2>
          <p id="overlay-desc">The zombies ate your brains...</p>
          <button id="restart-button">Restart</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * BASIC CONSTANTS
     ***********************/
    const ROWS = 5;
    const COLS = 9;
    const CELL_SIZE = 80; // used for positioning entities

    const PLANT_TYPES = {
      peashooter: {
        name: "Peashooter",
        cost: 100,
        reloadTime: 1.4,   // seconds between shots
        bulletSpeed: 180,  // px per second
        bulletDamage: 20,
        hp: 100
      }
    };

    const ZOMBIE_CONFIG = {
      speed: 18,          // px per second
      maxHp: 100,
      spawnIntervalMin: 3,
      spawnIntervalMax: 5
    };

    /***********************
     * DOM ELEMENTS
     ***********************/
    const gridEl = document.getElementById("grid");
    const entitiesEl = document.getElementById("entities");
    const sunAmountEl = document.getElementById("sun-amount");
    const statusTextEl = document.getElementById("status-text");
    const startButton = document.getElementById("start-button");
    const seedCards = document.querySelectorAll(".seed-card");
    const overlay = document.getElementById("overlay-message");
    const overlayTitle = document.getElementById("overlay-title");
    const overlayDesc = document.getElementById("overlay-desc");
    const restartButton = document.getElementById("restart-button");

    /***********************
     * GAME STATE
     ***********************/
    let cells = [];          // [row][col] => cell element
    let plants = [];         // {row, col, type, hp, reload}
    let zombies = [];        // {row, x, hp, el}
    let bullets = [];        // {row, x, el, damage, speed}
    let sun = 150;
    let currentPlantType = "peashooter";

    let running = false;
    let lastTime = null;
    let zombieSpawnTimer = 0;
    let nextSpawnTime = 999;  // set when wave starts
    let gameOver = false;
    let waveStarted = false;

    /***********************
     * INITIAL SETUP
     ***********************/
    function createGrid() {
      for (let r = 0; r < ROWS; r++) {
        cells[r] = [];
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.addEventListener("click", onCellClick);
          gridEl.appendChild(cell);
          cells[r][c] = cell;
        }
      }
    }

    createGrid();
    updateSunDisplay();

    /***********************
     * INPUT HANDLING
     ***********************/
    seedCards.forEach(card => {
      card.addEventListener("click", () => {
        seedCards.forEach(c => c.classList.remove("selected"));
        card.classList.add("selected");
        currentPlantType = card.dataset.plant;
        statusTextEl.textContent = `Selected: ${PLANT_TYPES[currentPlantType].name}. Click a tile to place.`;
      });
    });

    function onCellClick(e) {
      if (gameOver) return;
      const cell = e.currentTarget;
      const row = parseInt(cell.dataset.row, 10);
      const col = parseInt(cell.dataset.col, 10);

      // check if cell already has plant
      if (plants.some(p => p.row === row && p.col === col)) {
        statusTextEl.textContent = "There's already a plant in that tile.";
        return;
      }

      const plantConfig = PLANT_TYPES[currentPlantType];
      if (!plantConfig) return;

      if (sun < plantConfig.cost) {
        statusTextEl.textContent = "Not enough sun!";
        return;
      }

      sun -= plantConfig.cost;
      updateSunDisplay();
      placePlant(row, col, currentPlantType);
      statusTextEl.textContent = `${plantConfig.name} planted.`;
    }

    /***********************
     * PLANTS & BULLETS
     ***********************/
    function placePlant(row, col, type) {
      const cell = cells[row][col];

      const plantEl = document.createElement("div");
      plantEl.className = "plant";
      plantEl.textContent = "P";
      cell.appendChild(plantEl);

      plants.push({
        row,
        col,
        type,
        hp: PLANT_TYPES[type].hp,
        reload: 0,
        el: plantEl
      });
    }

    function shootFromPlant(plant) {
      const config = PLANT_TYPES[plant.type];
      const bullet = document.createElement("div");
      bullet.className = "bullet";
      entitiesEl.appendChild(bullet);

      const x = (plant.col + 0.5) * CELL_SIZE + 20; // slightly to the right of plant
      const y = plant.row * CELL_SIZE + CELL_SIZE * 0.5 - 4;

      bullets.push({
        row: plant.row,
        x,
        y,
        damage: config.bulletDamage,
        speed: config.bulletSpeed,
        el: bullet
      });

      updateBulletElementPosition(bullet, x, y);
    }

    function updateBulletElementPosition(el, x, y) {
      el.style.left = x + "px";
      el.style.top = y + "px";
    }

    /***********************
     * ZOMBIES
     ***********************/
    function spawnZombie() {
      const row = Math.floor(Math.random() * ROWS);
      const zombieEl = document.createElement("div");
      zombieEl.className = "zombie";
      entitiesEl.appendChild(zombieEl);

      const x = COLS * CELL_SIZE + 40; // start just off-screen to the right
      const y = row * CELL_SIZE + CELL_SIZE * 0.1;

      zombies.push({
        row,
        x,
        y,
        hp: ZOMBIE_CONFIG.maxHp,
        el: zombieEl
      });

      updateZombieElementPosition(zombieEl, x, y);
    }

    function updateZombieElementPosition(el, x, y) {
      el.style.left = x + "px";
      el.style.top = y + "px";
    }

    function scheduleNextZombieSpawn() {
      const min = ZOMBIE_CONFIG.spawnIntervalMin;
      const max = ZOMBIE_CONFIG.spawnIntervalMax;
      nextSpawnTime = min + Math.random() * (max - min);
      zombieSpawnTimer = 0;
    }

    /***********************
     * SUN
     ***********************/
    function updateSunDisplay() {
      sunAmountEl.textContent = sun;
    }

    /***********************
     * GAME LOOP
     ***********************/
    function gameLoop(timestamp) {
      if (!running) return;

      if (!lastTime) lastTime = timestamp;
      const delta = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;

      if (!gameOver) {
        updatePlants(delta);
        updateBullets(delta);
        updateZombies(delta);
        handleSpawning(delta);
      }

      requestAnimationFrame(gameLoop);
    }

    function updatePlants(delta) {
      plants.forEach(plant => {
        const config = PLANT_TYPES[plant.type];
        plant.reload -= delta;

        // Check if there is any zombie in this row to shoot
        const hasZombieInRow = zombies.some(z => z.row === plant.row);
        if (hasZombieInRow && plant.reload <= 0) {
          shootFromPlant(plant);
          plant.reload = config.reloadTime;
        }
      });
    }

    function updateBullets(delta) {
      const toRemove = [];
      bullets.forEach((b, index) => {
        b.x += b.speed * delta;

        // off board
        if (b.x > COLS * CELL_SIZE + 60) {
          entitiesEl.removeChild(b.el);
          toRemove.push(index);
          return;
        }

        // collision with zombie in same row
        for (let i = 0; i < zombies.length; i++) {
          const z = zombies[i];
          if (z.row !== b.row) continue;

          const zombieFront = z.x;
          const zombieBack = z.x - 40; // body width approx

          if (b.x >= zombieBack && b.x <= zombieFront) {
            // hit
            z.hp -= b.damage;
            entitiesEl.removeChild(b.el);
            toRemove.push(index);

            if (z.hp <= 0) {
              entitiesEl.removeChild(z.el);
              zombies.splice(i, 1);
              // reward a bit of sun
              sun += 25;
              updateSunDisplay();
            }
            break;
          }
        }

        if (!toRemove.includes(index)) {
          updateBulletElementPosition(b.el, b.x, b.y);
        }
      });

      // remove bullets from array (backwards so indexes don't shift)
      toRemove.sort((a, b) => b - a).forEach(i => bullets.splice(i, 1));
    }

    function updateZombies(delta) {
      for (let i = zombies.length - 1; i >= 0; i--) {
        const z = zombies[i];
        z.x -= ZOMBIE_CONFIG.speed * delta;

        // If zombie reaches left edge: game over
        if (z.x < 0) {
          triggerGameOver(false);
          return;
        }

        updateZombieElementPosition(z.el, z.x, z.y);
      }
    }

    function handleSpawning(delta) {
      if (!waveStarted) return;
      zombieSpawnTimer += delta;

      if (zombieSpawnTimer >= nextSpawnTime) {
        spawnZombie();
        scheduleNextZombieSpawn();
      }
    }

    /***********************
     * GAME OVER / RESTART
     ***********************/
    function triggerGameOver(playerWon) {
      gameOver = true;
      running = false;

      overlayTitle.textContent = playerWon ? "You survived!" : "Game Over";
      overlayDesc.textContent = playerWon
        ? "The wave of zombies has been held back... for now."
        : "The zombies reached your house and ate your brains.";
      overlay.classList.add("visible");
      statusTextEl.textContent = "Game finished. Press Restart to play again.";
    }

    function resetGameState() {
      // clear entities
      plants.forEach(p => {
        if (p.el && p.el.parentElement) {
          p.el.parentElement.removeChild(p.el);
        }
      });
      zombies.forEach(z => z.el && z.el.remove());
      bullets.forEach(b => b.el && b.el.remove());

      plants = [];
      zombies = [];
      bullets = [];
      sun = 150;
      updateSunDisplay();
      currentPlantType = "peashooter";
      seedCards.forEach(c => c.classList.remove("selected"));
      document.querySelector('.seed-card[data-plant="peashooter"]').classList.add("selected");

      lastTime = null;
      zombieSpawnTimer = 0;
      nextSpawnTime = 999;
      gameOver = false;
      waveStarted = false;
      overlay.classList.remove("visible");

      statusTextEl.textContent = "Click a seed, then click a tile to place a plant.";
    }

    /***********************
     * BUTTON HANDLERS
     ***********************/
    startButton.addEventListener("click", () => {
      if (waveStarted) {
        statusTextEl.textContent = "Wave already started! Hold the line!";
        return;
      }
      waveStarted = true;
      running = true;
      scheduleNextZombieSpawn();
      statusTextEl.textContent = "Wave started! Zombies will spawn from the right.";
      requestAnimationFrame(gameLoop);
    });

    restartButton.addEventListener("click", () => {
      resetGameState();
      running = true;
      requestAnimationFrame(gameLoop);
    });

    // Auto-start loop so plants animate even before wave
    running = true;
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>