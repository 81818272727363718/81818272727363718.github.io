<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>party.web — 3D Prototype (Mouse Look)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: radial-gradient(circle at top, #1a1a2e, #050509, #000);
      font-family: system-ui, sans-serif;
      color: #fff;
    }

    canvas { display: block; }

    /* Start overlay */
    #startOverlay {
      position: fixed;
      inset: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(8px);
    }

    .card {
      background: rgba(0,0,0,0.55);
      padding: 24px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      width: 360px;
      text-align: center;
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
    }

    .btn {
      margin-top: 14px;
      padding: 10px 22px;
      border-radius: 999px;
      border: none;
      background: #ff5c9a;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      font-size: 15px;
    }

    .btn:hover { filter: brightness(1.1); }

    /* Crosshair */
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 12px;
      height: 12px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      opacity: 0.7;
      z-index: 2;
    }

    #crosshair::before,
    #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.8);
    }

    #crosshair::before {
      left: 50%; top: 0;
      width: 2px; height: 12px;
      transform: translateX(-50%);
    }

    #crosshair::after {
      top: 50%; left: 0;
      width: 12px; height: 2px;
      transform: translateY(-50%);
    }

    /* Hint text */
    #hintOverlayText {
      position: fixed;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%);
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      font-size: 0.75rem;
      z-index: 2;
    }

    /* Ending overlay */
    #endingOverlayInner {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 9;
    }

    #endingOverlayInner.visible {
      opacity: 1;
      pointer-events: auto;
    }
  </style>
</head>
<body>

  <!-- Start Screen -->
  <div id="startOverlay">
    <div class="card">
      <h1><span style="color:#ff5c9a">party</span>.web</h1>
      <p>Walk to the house… or leave.</p>
      <p><strong>Controls:</strong> Left-drag to look, WASD to move, Shift to sprint, R to restart.</p>
      <button id="startButton" class="btn">Enter Party</button>
    </div>
  </div>

  <!-- Crosshair -->
  <div id="crosshair"></div>

  <!-- Hint -->
  <div id="hintOverlayText">Left-drag to look around. Find the house.</div>

  <!-- Ending Screen -->
  <div id="endingOverlayInner">
    <div class="card">
      <h2 id="endingCardTitle"></h2>
      <p id="endingCardSubtitle"></p>
      <p id="endingDetails"></p>
      <p style="color:#ff5c9a; margin-top:10px;">Press R to restart</p>
    </div>
  </div>

  <!-- 3D Scene -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

    let scene, camera, renderer;
    let player;          // holder for position & yaw
    let pitch = 0;       // camera up/down rotation
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, sprint = false;
    let ended = false;

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const clock = new THREE.Clock();
    const startPos = new THREE.Vector3(0, 0, 18);

    let tixMesh;
    const triggers = [];

    // mouse look
    let mouseDown = false;
    let lastMouseX = 0, lastMouseY = 0;
    const lookSensitivity = 0.003;

    const endingOverlayInner = document.getElementById("endingOverlayInner");
    const endingTitle = document.getElementById("endingCardTitle");
    const endingSubtitle = document.getElementById("endingCardSubtitle");
    const endingDetails = document.getElementById("endingDetails");
    const hintText = document.getElementById("hintOverlayText");
    const startOverlay = document.getElementById("startOverlay");

    init();
    animate();

    function init() {
      // Scene & camera
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050509, 0.045);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      // Player object (controls position & yaw)
      player = new THREE.Object3D();
      player.position.copy(startPos);
      scene.add(player);

      camera.position.set(0, 1.7, 0);
      player.add(camera);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.AmbientLight(0x8888aa, 0.9));
      const moon = new THREE.DirectionalLight(0x99bbff, 0.8);
      moon.position.set(20, 40, 10);
      scene.add(moon);

      // World
      createGround();
      createHouse();
      createTrees();
      createSubject();
      createCar();
      createTix();
      setupTriggers();

      // Start button
      document.getElementById("startButton").addEventListener("click", () => {
        startOverlay.style.display = "none";
        hintText.textContent = "Left-drag to look, WASD to move. Find the house.";
      });

      // Keyboard
      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);

      // Mouse
      renderer.domElement.addEventListener("mousedown", onMouseDown);
      renderer.domElement.addEventListener("mouseup", onMouseUp);
      renderer.domElement.addEventListener("mouseleave", onMouseUp);
      renderer.domElement.addEventListener("mousemove", onMouseMove);

      // Resize
      window.addEventListener("resize", onResize);
    }

    /* World creation */

    function createGround() {
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(80, 80),
        new THREE.MeshStandardMaterial({ color: 0x0b0f16, roughness: 1 })
      );
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      const path = new THREE.Mesh(
        new THREE.PlaneGeometry(4, 20),
        new THREE.MeshStandardMaterial({ color: 0x1c1f2b, roughness: 0.8 })
      );
      path.rotation.x = -Math.PI / 2;
      path.position.set(0, 0.01, 4);
      scene.add(path);
    }

    function createHouse() {
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(16, 8, 16),
        new THREE.MeshStandardMaterial({ color: 0x141421, roughness: 0.8 })
      );
      body.position.set(0, 4, -10);
      scene.add(body);

      const roof = new THREE.Mesh(
        new THREE.ConeGeometry(10, 4, 4),
        new THREE.MeshStandardMaterial({ color: 0x1f1b3a, roughness: 0.9 })
      );
      roof.position.set(0, 9, -10);
      roof.rotation.y = Math.PI / 4;
      scene.add(roof);

      const door = new THREE.Mesh(
        new THREE.PlaneGeometry(3, 4),
        new THREE.MeshBasicMaterial({ color: 0xff5c9a, transparent: true, opacity: 0.5 })
      );
      door.position.set(0, 2, -2);
      scene.add(door);

      const partyLight = new THREE.PointLight(0xff99cc, 2, 20);
      partyLight.position.set(0, 4, -12);
      scene.add(partyLight);
    }

    function createTrees() {
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x382626 });
      const leafMat = new THREE.MeshStandardMaterial({ color: 0x13281c });

      const positions = [
        [-10, -4],
        [-14, -8],
        [10, -3],
        [14, -7],
        [-16, 2],
        [16, 4]
      ];

      positions.forEach(([x, z]) => {
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.7, 4),
          trunkMat
        );
        trunk.position.set(x, 2, z);
        scene.add(trunk);

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(2.2),
          leafMat
        );
        leaves.position.set(x, 5, z);
        scene.add(leaves);
      });
    }

    function createSubject() {
      const subject = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.8, 1.8, 8, 16),
        new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: 0xffffff,
          emissiveIntensity: 0.08
        })
      );
      subject.position.set(-4, 2.3, 8);
      subject.userData.subject = true;
      scene.add(subject);
    }

    function createCar() {
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(4, 1, 2),
        new THREE.MeshStandardMaterial({ color: 0x30353f, roughness: 0.8 })
      );
      body.position.set(0, 0.6, 24);
      scene.add(body);
    }

    function createTix() {
      tixMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.2, 0.5),
        new THREE.MeshStandardMaterial({
          color: 0xffd15c,
          emissive: 0xffd15c,
          emissiveIntensity: 0.6
        })
      );
      tixMesh.position.set(6, 0.3, 10);
      scene.add(tixMesh);
    }

    /* Triggers / endings */

    function setupTriggers() {
      triggers.push({
        name: "fake_party",
        type: "volume",
        min: new THREE.Vector3(-1.5, 0, -1),
        max: new THREE.Vector3(1.5, 3, -4.5),
        done: false
      });

      triggers.push({
        name: "inside_house",
        type: "volume",
        min: new THREE.Vector3(-7, 0, -6),
        max: new THREE.Vector3(7, 5, -20),
        done: false
      });

      triggers.push({
        name: "car",
        type: "volume",
        min: new THREE.Vector3(-2, 0, 22),
        max: new THREE.Vector3(2, 3, 27),
        done: false
      });

      triggers.push({
        name: "tix",
        type: "tix",
        radius: 1.4,
        done: false
      });
    }

    function triggerEnding(id) {
      if (ended) return;
      ended = true;

      let title = "", sub = "", det = "";

      if (id === "fake_party") {
        title = "Fake Party";
        sub = "That didn’t look normal.";
        det = "Something inside was watching you through the walls.";
      } else if (id === "inside_house") {
        title = "Winner";
        sub = "You stepped into the real party.";
        det = "But the house wasn’t built for you.";
      } else if (id === "car") {
        title = "Refusal";
        sub = "You chose to go home.";
        det = "In the distance, the house is still there. Waiting.";
      } else if (id === "tix") {
        title = "Tix Ending";
        sub = "You touched the forbidden ticket.";
        det = "Nostalgia has a price. You just paid it.";
      }

      endingTitle.textContent = title + " Ending";
      endingSubtitle.textContent = sub;
      endingDetails.textContent = det;
      hintText.textContent = "Press R to restart.";
      endingOverlayInner.classList.add("visible");
    }

    function resetGame() {
      ended = false;
      endingOverlayInner.classList.remove("visible");
      player.position.copy(startPos);
      player.rotation.set(0, 0, 0);
      pitch = 0;
      camera.rotation.set(0, 0, 0);
      hintText.textContent = "Left-drag to look around. Find the house.";
    }

    /* Input */

    function onKeyDown(e) {
      if (ended && e.code === "KeyR") {
        resetGame();
        return;
      }

      switch (e.code) {
        case "KeyW": moveForward = true; break;
        case "KeyA": moveLeft = true; break;
        case "KeyS": moveBackward = true; break;
        case "KeyD": moveRight = true; break;
        case "ShiftLeft":
        case "ShiftRight":
          sprint = true; break;
      }
    }

    function onKeyUp(e) {
      switch (e.code) {
        case "KeyW": moveForward = false; break;
        case "KeyA": moveLeft = false; break;
        case "KeyS": moveBackward = false; break;
        case "KeyD": moveRight = false; break;
        case "ShiftLeft":
        case "ShiftRight":
          sprint = false; break;
      }
    }

    function onMouseDown(e) {
      if (e.button === 0) {
        mouseDown = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
    }

    function onMouseUp(e) {
      if (e.button === 0) {
        mouseDown = false;
      }
    }

    function onMouseMove(e) {
      if (!mouseDown || ended) return;

      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;

      // yaw
      player.rotation.y -= dx * lookSensitivity;

      // pitch
      pitch -= dy * lookSensitivity;
      const maxPitch = Math.PI / 3;
      const minPitch = -Math.PI / 3;
      pitch = Math.max(minPitch, Math.min(maxPitch, pitch));
      camera.rotation.x = pitch;
    }

    /* Triggers check */

    function checkTriggers() {
      const camPos = new THREE.Vector3();
      camera.getWorldPosition(camPos);

      for (const t of triggers) {
        if (t.done) continue;

        if (t.type === "volume") {
          if (
            camPos.x >= t.min.x && camPos.x <= t.max.x &&
            camPos.y >= t.min.y && camPos.y <= t.max.y &&
            camPos.z >= t.min.z && camPos.z <= t.max.z
          ) {
            t.done = true;
            triggerEnding(t.name);
            return;
          }
        }

        if (t.type === "tix") {
          if (camPos.distanceTo(tixMesh.position) <= t.radius) {
            t.done = true;
            triggerEnding("tix");
            return;
          }
        }
      }
    }

    /* Resize */

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /* Main loop */

    function animate() {
      requestAnimationFrame(animate);

      const dt = clock.getDelta();

      if (!ended) {
        const speed = sprint ? 8 : 4; // units per second

        direction.set(0, 0, 0);
        if (moveForward) direction.z -= 1;
        if (moveBackward) direction.z += 1;
        if (moveLeft) direction.x -= 1;
        if (moveRight) direction.x += 1;

        if (direction.lengthSq() > 0) {
          direction.normalize();

          // rotate move vector by player's yaw
          const yaw = player.rotation.y;
          const sin = Math.sin(yaw);
          const cos = Math.cos(yaw);

          const moveX = direction.x * cos - direction.z * sin;
          const moveZ = direction.x * sin + direction.z * cos;

          player.position.x += moveX * speed * dt;
          player.position.z += moveZ * speed * dt;

          // keep on ground
          player.position.y = 0;
        }

        // world bounds
        const limit = 36;
        player.position.x = THREE.MathUtils.clamp(player.position.x, -limit, limit);
        player.position.z = THREE.MathUtils.clamp(player.position.z, -limit, limit);

        checkTriggers();
      }

      renderer.render(scene, camera);
    }
  </script>

</body>
</html>
