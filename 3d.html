<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Environment Demo â€” Browser</title>
  <style>
    :root{--bg:#0b0f14;--panel:rgba(255,255,255,0.06);--accent:#7ce7ff}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#07111a, #0b0f14);font-family:Inter,system-ui,Arial}
    canvas{display:block;cursor:none;}
    #overlay{position:fixed;left:0;top:0;pointer-events:none;z-index:10;display:flex;justify-content:flex-start;align-items:flex-start;padding:14px}
    .panel{background:var(--panel);backdrop-filter:blur(4px);color:#e9f9ff;padding:10px 12px;border-radius:10px;pointer-events:auto}
    #leftPanel{max-width:320px}
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script>
</head>
<body>
  <div id="overlay">
    <div id="leftPanel" class="panel">
      <div style="font-weight:700;margin-bottom:6px">3D Environment Demo</div>
      <div class="hint">Use <strong>W A S D</strong> to move relative to view, <strong>Space</strong> to jump, <strong>B</strong> to toggle heirloom, <strong>K</strong> to inspect, <strong>O/L/I/P</strong> to look up/down/left/right, <strong>Click</strong> to fire.</div>
      <div style="margin-top:8px"><button id="startBtn">Enter Environment</button></div>
      <div style="margin-top:8px;font-size:13px;opacity:0.9">Pointer lock will snap the mouse to the screen for FPS movement.</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'GLTFLoader';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x071018);
    scene.fog = new THREE.FogExp2(0x071018, 0.02);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
    camera.position.set(0,1.7,10);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5));
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xbde0ff, 0x081122, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(-10,20,10);
    scene.add(dir);

    const groundMat = new THREE.MeshStandardMaterial({color:0x1d2b36, roughness:1});
    const groundGeo = new THREE.PlaneGeometry(200,200, 50,50);
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    const structures = new THREE.Group();
    const boxMat = new THREE.MeshStandardMaterial({color:0x4b6b7a});
    for(let i=0;i<20;i++){
      const w=1+Math.random()*4, h=1+Math.random()*6, d=1+Math.random()*4;
      const geo = new THREE.BoxGeometry(w,h,d);
      const m = new THREE.Mesh(geo, boxMat);
      m.position.set((Math.random()-0.5)*100, h/2, (Math.random()-0.5)*100);
      structures.add(m);
    }
    scene.add(structures);

    const platformMat = new THREE.MeshStandardMaterial({color:0xffaa33});
    const platforms = new THREE.Group();
    const platformPositions = [{x:0,y:3,z:0},{x:5,y:6,z:-5},{x:-7,y:9,z:7},{x:10,y:12,z:5}];
    platformPositions.forEach(pos=>{
      const geo = new THREE.BoxGeometry(4,0.5,4);
      const plat = new THREE.Mesh(geo, platformMat);
      plat.position.set(pos.x,pos.y,pos.z);
      platforms.add(plat);
    });
    scene.add(platforms);

    // Butterfly knife heirloom
    const knife = new THREE.Group();
    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.02,0.005,0.25), new THREE.MeshStandardMaterial({color:0xAAAAAA, metalness:1, roughness:0.1}));
    blade.position.set(0,0,0.125);
    const handleGeo = new THREE.BoxGeometry(0.02,0.05,0.125);
    const handleMat = new THREE.MeshStandardMaterial({color:0x333333, metalness:0.5, roughness:0.5});
    const handleLeft = new THREE.Mesh(handleGeo, handleMat);
    const handleRight = new THREE.Mesh(handleGeo, handleMat);
    handleLeft.position.set(-0.015,0,0.0625);
    handleRight.position.set(0.015,0,0.0625);
    knife.add(blade, handleLeft, handleRight);
    knife.position.set(0.3,-0.25,-0.5);
    knife.rotation.set(-0.2,-0.5,-0.1);
    knife.visible = false;
    camera.add(knife);

    // Gun stub (replace with actual model later)
    const gun = new THREE.Mesh(
      new THREE.BoxGeometry(0.2,0.1,0.5),
      new THREE.MeshStandardMaterial({color:0x222222, metalness:0.8, roughness:0.3})
    );
    gun.position.set(0.3,-0.2,-0.5);
    gun.rotation.set(-0.2,-0.5,-0.1);
    gun.visible = true;
    camera.add(gun);

    const sky = new THREE.Mesh(new THREE.SphereGeometry(150,16,8), new THREE.MeshBasicMaterial({color:0x071018, side:THREE.BackSide}));
    scene.add(sky);

    let lookState={pitch:0, yaw:0}, lookSensitivity=0.0025;
    const velocity = new THREE.Vector3();
    const move = {forward:false, back:false, left:false, right:false, jump:false};
    let canJump=true, inspecting=false, inspectProgress=0;

    function onKey(e){
      const down = e.type==='keydown';
      if(e.code==='KeyW') move.forward=down;
      if(e.code==='KeyS') move.back=down;
      if(e.code==='KeyA') move.left=down;
      if(e.code==='KeyD') move.right=down;
      if(e.code==='Space') move.jump=down;
      if(e.code==='KeyO') lookState.pitch-=0.05;
      if(e.code==='KeyL') lookState.pitch+=0.05;
      if(e.code==='KeyI') lookState.yaw-=0.05;
      if(e.code==='KeyP') lookState.yaw+=0.05;
      if(e.code==='KeyB' && down) knife.visible=!knife.visible;
      if(e.code==='KeyK' && down && knife.visible){ inspecting=true; inspectProgress=0; }
    }
    window.addEventListener('keydown', onKey);
    window.addEventListener('keyup', onKey);

    function onMouseMove(e){
      const dx = e.movementX||0, dy = e.movementY||0;
      lookState.yaw -= dx*lookSensitivity;
      lookState.pitch -= dy*lookSensitivity;
      lookState.pitch=Math.max(-Math.PI/2+0.05,Math.min(Math.PI/2-0.05,lookState.pitch));
    }
    window.addEventListener('mousemove', onMouseMove);

    window.addEventListener('resize', ()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});

    const clock = new THREE.Clock();

    function animate(){
      const dt = Math.min(clock.getDelta(),0.05);
      const dirVec = new THREE.Vector3();
      if(move.forward) dirVec.z -= 1;
      if(move.back) dirVec.z += 1;
      if(move.left) dirVec.x -= 1;
      if(move.right) dirVec.x += 1;
      dirVec.normalize();
      const camQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, lookState.yaw, 0, 'YXZ'));
      dirVec.applyQuaternion(camQuat);
      const speed = 10;
      velocity.x += (dirVec.x*speed-velocity.x)*10*dt;
      velocity.z += (dirVec.z*speed-velocity.z)*10*dt;
      velocity.y -= 9.8*dt;
      if(move.jump && canJump){velocity.y=5;canJump=false;}
      camera.position.addScaledVector(velocity, dt);
      camera.quaternion.setFromEuler(new THREE.Euler(lookState.pitch, lookState.yaw,0,'YXZ'));

      const playerY=camera.position.y; let landed=false;
      platforms.children.forEach(plat=>{
        const px=plat.position.x,pz=plat.position.z,half=2;
        if(camera.position.x>px-half && camera.position.x<px+half && camera.position.z>pz-half && camera.position.z<pz+half && velocity.y<=0){
          if(playerY<=plat.position.y+1.7){camera.position.y=plat.position.y+1.7;velocity.y=0;canJump=true;landed=true;}
        }
      });
      if(camera.position.y<=1.7 && !landed){camera.position.y=1.7;velocity.y=0;canJump=true;}

      // Knife animation
      if(knife.visible){
        if(inspecting){
          inspectProgress+=dt;
          const t=Math.min(inspectProgress/3,1);
          knife.rotation.x=-0.2+Math.sin(inspectProgress*10)*0.5;
          knife.rotation.y=-0.5+Math.sin(inspectProgress*8)*0.7;
          knife.rotation.z=-0.1+Math.sin(inspectProgress*12)*0.5;
          knife.position.x=0.3+Math.sin(inspectProgress*6)*0.03;
          knife.position.y=-0.25+Math.cos(inspectProgress*6)*0.03;
          knife.position.z=-0.5+Math.sin(inspectProgress*6)*0.03;
          handleLeft.rotation.z=-Math.PI/4*t;
          handleRight.rotation.z=Math.PI/4*t;
          if(inspectProgress>3){inspecting=false;inspectProgress=0;}
        } else {
          knife.position.x+=(0.3-knife.position.x)*0.1;
          knife.position.y+=(-0.25-knife.position.y)*0.1;
          knife.position.z+=(-0.5-knife.position.z)*0.1;
          knife.rotation.x+=(-0.2-knife.rotation.x)*0.1;
          knife.rotation.y+=(-0.5-knife.rotation.y)*0.1;
          knife.rotation.z+=(-0.1-knife.rotation.z)*0.1;
          handleLeft.rotation.z+=(0-handleLeft.rotation.z)*0.1;
          handleRight.rotation.z+=(0-handleRight.rotation.z)*0.1;
        }
      }

      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }

    document.getElementById('startBtn').addEventListener('click', ()=>{
      renderer.domElement.requestPointerLock();
      animate();
    });
  </script>
</body>
</html>
